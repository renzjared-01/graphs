# 24 ###########################################################
from random import randint

def partition(A, l, r):
    pivot = A[r]
    i = l - 1
    for j in range(l, r):
        if A[j] <= pivot:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1


def _quicksort(A, l, r):
    if l < r:
        m = partition(A, l, r)
        _quicksort(A, l, m - 1)
        _quicksort(A, m + 1, r)
    return A

def quicksort1(A, l, r):
    A = list(A)
    return _quicksort(A, l, r)


def _randomized_quicksort(A, l, r):
    if l < r:
        pivot = randint(l, r)
        A[pivot], A[r] = A[r], A[pivot]
        m = partition(A, l, r)
        _randomized_quicksort(A, l, m - 1)
        _randomized_quicksort(A, m + 1, r)
    return A

def randomized_quicksort(A, l, r):
    A = list(A)
    return _randomized_quicksort(A, l, r)


li = (3, 1, 4, 2, 5, 7)
res = randomized_quicksort(li, 0, len(li) - 1)
print(res)

####

def partition_hoare(A, l, r):
    # choose random pivot value (no swap required)
    pivot = A[randint(l, r)]
    i = l - 1
    j = r + 1
    while True:
        i += 1
        while A[i] < pivot:
            i += 1
        j -= 1
        while A[j] > pivot:
            j -= 1
        if i >= j:
            return j
        A[i], A[j] = A[j], A[i]

def quicksort_hoare(A, l=0, r=None):
    if r is None:
        A = list(A)
        r = len(A) - 1
    if l < r:
        p = partition_hoare(A, l, r)
        quicksort_hoare(A, l, p)
        quicksort_hoare(A, p + 1, r)
    return A

# Example
arr = [3,1,4,2,5,7,2,3]
print(quicksort_hoare(arr))

###########################################################

from random import randint

def quicksort_3way(A, l=0, r=None):
    if r is None:
        A = list(A)   # operate on a copy; remove to mutate in-place
        r = len(A) - 1
    def _qs(l, r):
        if l >= r:
            return
        # choose random pivot and move it to A[l]
        k = randint(l, r)
        A[l], A[k] = A[k], A[l]
        pivot = A[l]

        lt = l        # A[l..lt-1] < pivot
        i  = l + 1    # A[lt..i-1] == pivot
        gt = r        # A[gt+1..r] > pivot

        while i <= gt:
            if A[i] < pivot:
                A[lt], A[i] = A[i], A[lt]
                lt += 1
                i += 1
            elif A[i] > pivot:
                A[i], A[gt] = A[gt], A[i]
                gt -= 1
            else:
                i += 1

        # Recurse on < pivot and > pivot regions
        _qs(l, lt - 1)
        _qs(gt + 1, r)

    _qs(l, r)
    return A

# Example
arr = [3,1,4,2,5,7,2,3,3,2,2]
print(quicksort_3way(arr))

############################################################
from dataclasses import dataclass
from random import randint, choice, shuffle

@dataclass
class Node:
    val: int | float
    up: "Node | None" = None
    down: "Node | None" = None
    left: "Node | None" = None
    right: "Node | None" = None

    def is_rightmost(self):
        return self.right is None

    def is_bottommost(self):
        return self.down is None

    def __repr__(self):
        return str(self.val)


class SkipList:
    def __init__(self, vals=()):
        self.levels = [self.create_sentinel()]
        self.size = 0
        self.cap = 5
        for v in vals:
            self.insert(v)
        super().__init__()

    def __len__(self):
        return self.size

    def __str__(self):
        ss = []
        for idx, s in enumerate(self.levels):
            l = [f'{idx}:']
            t = s
            while t is not None:
                l.append(str(t))
                t = t.right
            ss.append(' '.join(l))
        return '\n'.join(ss)

    def _will_promote(self):
        return choice((True, False))

    def create_sentinel(self):
        return Node(float('-inf'))

    def find(self, val):
        curr = self.levels[-1]
        self._chain = list()

        for _ in range(len(self.levels)):
            # go right as much as possible at current level
            while not curr.is_rightmost() and val >= curr.right.val:
                curr = curr.right
            self._chain.append(curr)

            # go down next level if possible
            if not curr.is_bottommost():
                curr = curr.down

        self._chain = self._chain[::-1]
        return val == curr.val

    def insert(self, val):

        def insert_and_repoint(node, left, right, down=None):
            node.left = left
            node.right = right
            left.right = node
            if right is not None:
                right.left = node
            if down is not None:
                node.down = down
                down.up = node

        found = self.find(val)
        lvl = 0
        left = self._chain[lvl]
        if not found:
            self.size += 1
            new = Node(val)
            insert_and_repoint(new, left, left.right)

            while self._will_promote():
                lvl += 1
                # if lvl >= self.cap:
                #     break
                if lvl == len(self.levels):
                    sentinel = self.levels[-1]
                    sentinel_up = self.create_sentinel()
                    sentinel.up = sentinel_up
                    sentinel_up.down = sentinel
                    self.levels.append(sentinel_up)

                    new_up = Node(val)
                    insert_and_repoint(
                        new_up, sentinel_up, sentinel_up.right,
                        down=new
                    )

                    new = new_up
                else:
                    left = self._chain[lvl]

                    new_up = Node(val)
                    insert_and_repoint(
                        new_up, left, left.right,
                        down=new
                    )

                    new = new_up

    def delete(self, val):
        found = self.find(val)
        if found:
            self.size -= 1
            node = self._chain[0]
            while node is not None:
                left, right = node.left, node.right
                left.right = right
                if right is not None:
                    right.left = left
                node = node.up
        return found


sl = SkipList()
vals = [*range(1, 21)]
shuffle(vals)
for i in vals:
    sl.insert(i)
print(sl)
print('deletes')
for i in vals:
    print(i)
    sl.delete(i)
    print(sl)
    print('---')

############################################################
# Order Statistics
# Given an array a of length n, and k such that 0 ≤ k < n, find the
# element at index k when it is sorted.

from random import randint
from typing import List, Any

def partition(A: List[Any], l: int, r: int) -> int:
    """Lomuto partition: pivot = A[r]; returns pivot final index."""
    pivot = A[r]
    i = l - 1
    for j in range(l, r):
        if A[j] <= pivot:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i + 1

def quickselect(A: List[Any], k: int) -> Any:
    """
    Return the element that would be at index k if A were sorted (0-based).
    This modifies A in-place. Expected O(n) time (randomized).
    Raises IndexError if k is out of bounds.
    """
    n = len(A)
    if not (0 <= k < n):
        raise IndexError("k out of bounds")

    def _qs(l: int, r: int) -> Any:
        if l == r:
            return A[l]
        # random pivot to avoid worst-case
        pivot_idx = randint(l, r)
        A[pivot_idx], A[r] = A[r], A[pivot_idx]
        p = partitiono(A, l, r)
        # p is pivot final index
        if k == p:
            return A[p]
        elif k < p:
            return _qs(l, p - 1)
        else:
            return _qs(p + 1, r)

    return _qs(0, n - 1)


# 25 ###########################################################
# five points in line
from random import sample

from dataclasses import dataclass
from fractions import Fraction


@dataclass(frozen=True)
class Point[T: (int, float, Fraction)]:
    # floating-point is evil
    x: T
    y: T
    # z: int

    def __sub__(self, p: "Point") -> "Vec2D":
        return Vec2D(self, p)


class Vec2D:
    def __init__(self, p2: Point, p1: Point = Point(0, 0)):
        self.x = p2.x - p1.x
        self.y = p2.y - p1.y
        super().__init__()

    def __add__(self, v: "Vec2D") -> "Vec2D":
        return Vec2D(
            Point(self.x + v.x, self.y + v.y)
        )

    def __radd__(self, v: "Vec2D") -> "Vec2D":
        return self.__add__(v)

    def __sub__(self, v: "Vec2D") -> "Vec2D":
        return Vec2D(
            Point(self.x - v.x, self.y - v.y)
        )

    def __rmul__(self, s: int) -> "Vec2D":
        return Vec2D(Point(s * self.x, s * self.y))

    def mag2(self) -> int:
        return self.x**2 + self.y**2

    def dot(self, v: "Vec2D") -> int:
        return self.x * v.x + self.y * v.y

    def cross(self, v: "Vec2D") -> int:
        return self.x * v.y - self.y * v.x


points_with_answer = [
    (4, 4), (-1, -18), (8, -14), (-3, 20), (7, 5),
    (16, -3), (-9, -13), (-14, -19), (-2, -17), (6, 8),
    (-11, -3), (-9, 6), (-3, 2), (-15, -4), (0, -17),
    (11, 13), (8, -13), (10, 7), (3, -7), (18, -6),
    (19, -3), (0, -13), (4, -5),
    (4, 7), (6, 7)
]
points_with_no_answer = [
    (4, 4), (-1, -18), (8, -14), (-3, 20), (7, 5),
    (16, -3), (-9, -13), (-14, -19), (-2, -17), (6, 8),
    (-11, -3), (-9, 6), (-3, 2), (-15, -4), (0, -17),
    (11, 13), (8, -13), (10, 7), (3, -7), (18, -6),
    (19, -3), (0, -13), (4, -500), # (4, -5),
    (4, 7), (6, 7)
]

def find_line_brute(points):
    pts = [Point(*p) for p in points]
    n = len(pts)
    for i in range(n):
        for j in range(i + 1, n):
            p_i = pts[i]
            p_j = pts[j]
            count = 0
            for k in range(n):
                p_k = pts[k]
                v1 = p_j - p_i
                v2 = p_k - p_i
                # collinear check
                if v1.cross(v2) == 0:
                    count += 1
            if count * 5 >= n:
                return (p_i, p_j)
    return None


def find_line_lasvegas(points):
    pts = [Point(*p) for p in points]
    attempts = 0
    while True:
        attempts += 1
        p1, p2 = sample(pts, 2)
        count = 0
        for p3 in pts:
            v1 = p3 - p1
            v2 = p3 - p2
            if v1.cross(v2) == 0:
                count += 1
        if count >= len(pts) / 5:
            return attempts, (p1, p2)


def find_line_mc(points):
    pts = [Point(*p) for p in points]
    attempts = 0
    K = 2000
    for _ in range(K):
        attempts += 1
        p1, p2 = sample(pts, 2)
        count = 0
        for p3 in pts:
            v1 = p3 - p1
            v2 = p3 - p2
            if v1.cross(v2) == 0:
                count += 1
        if count >= len(pts) / 5:
            return attempts, (p1, p2)
    return attempts, None


num_attempts, ans = find_line_lasvegas(points_with_answer)
print(num_attempts, ans)
num_attempts, ans = find_line_mc(points_with_answer)
print(num_attempts, ans)
num_attempts, ans = find_line_mc(points_with_no_answer)
print(num_attempts, ans)

# 26 ###########################################################
# Hashing
class HashMapChaining:
    """
    A simple Hash Map implementation using Separate Chaining.
    """
    def __init__(self, capacity=10):
        # c is the capacity (number of buckets)
        self.capacity = capacity 
        # .a: array of lists (buckets), initialized to 'capacity' empty lists
        self.buckets = [[] for _ in range(self.capacity)]

    def _hash(self, key):
        """
        The hash function h(k). 
        Uses Python's built-in hash() and the modulo operator to get an index 
        within the array bounds [0, capacity - 1].
        """
        # Ensure the hash result is non-negative and within capacity
        return hash(key) % self.capacity

    def set(self, key, value):
        """
        Inserts or updates the value associated with the key.
        Corresponds to the .set(k, v) method.
        """
        index = self._hash(key)
        bucket = self.buckets[index]

        # 1. Search for an existing key and update if found
        for i, (k_prime, v_prime) in enumerate(bucket):
            if k_prime == key:
                # Replace old entry: .a[h(k)][i] ≔ (k, v)
                bucket[i] = (key, value)
                return

        # 2. If key is new, append the new entry
        # .a[h(k)].append((k, v))
        bucket.append((key, value))

    def get(self, key):
        """
        Retrieves the value associated with the key.
        Corresponds to the .get(k) method.
        """
        index = self._hash(key)
        bucket = self.buckets[index]

        # 1. Iterate the chain and return value if key is found
        for k_prime, v_prime in bucket:
            if k_prime == key:
                return v_prime
        
        # 2. Key not found: key error
        raise KeyError(f"Key '{key}' not found in the map")

# --- Example Usage ---
my_map = HashMapChaining(capacity=5)

# Insert new entries
my_map.set("apple", 100)
my_map.set("banana", 200)
my_map.set("cherry", 300)

# Retrieve a value
print(f"Value for 'banana': {my_map.get('banana')}")

# Update an entry
my_map.set("apple", 150)
print(f"New value for 'apple': {my_map.get('apple')}")

# Show the underlying structure (demonstrates chaining/hashing)
print("\nUnderlying Buckets:")
for i, chain in enumerate(my_map.buckets):
    print(f"Bucket {i}: {chain}")

# Example of a key error
try:
    my_map.get("grape")
except KeyError as e:
    print(f"\nCaught Error: {e}")

############################################################
############################################################
############################################################
