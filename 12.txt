# 24 ###########################################################
from random import randint

def partition(A, l, r):
    pivot = A[r]
    i = l - 1
    for j in range(l, r):
        if A[j] <= pivot:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i + 1], A[r] = A[r], A[i + 1]
    return i + 1


def _quicksort(A, l, r):
    if l < r:
        m = partition(A, l, r)
        _quicksort(A, l, m - 1)
        _quicksort(A, m + 1, r)
    return A

def quicksort1(A, l, r):
    A = list(A)
    return _quicksort(A, l, r)


def _randomized_quicksort(A, l, r):
    if l < r:
        pivot = randint(l, r)
        A[pivot], A[r] = A[r], A[pivot]
        m = partition(A, l, r)
        _randomized_quicksort(A, l, m - 1)
        _randomized_quicksort(A, m + 1, r)
    return A

def randomized_quicksort(A, l, r):
    A = list(A)
    return _randomized_quicksort(A, l, r)


li = (3, 1, 4, 2, 5, 7)
res = randomized_quicksort(li, 0, len(li) - 1)
print(res)

####

def partition_hoare(A, l, r):
    # choose random pivot value (no swap required)
    pivot = A[randint(l, r)]
    i = l - 1
    j = r + 1
    while True:
        i += 1
        while A[i] < pivot:
            i += 1
        j -= 1
        while A[j] > pivot:
            j -= 1
        if i >= j:
            return j
        A[i], A[j] = A[j], A[i]

def quicksort_hoare(A, l=0, r=None):
    if r is None:
        A = list(A)
        r = len(A) - 1
    if l < r:
        p = partition_hoare(A, l, r)
        quicksort_hoare(A, l, p)
        quicksort_hoare(A, p + 1, r)
    return A

# Example
arr = [3,1,4,2,5,7,2,3]
print(quicksort_hoare(arr))

###########################################################

from random import randint

def quicksort_3way(A, l=0, r=None):
    if r is None:
        A = list(A)   # operate on a copy; remove to mutate in-place
        r = len(A) - 1
    def _qs(l, r):
        if l >= r:
            return
        # choose random pivot and move it to A[l]
        k = randint(l, r)
        A[l], A[k] = A[k], A[l]
        pivot = A[l]

        lt = l        # A[l..lt-1] < pivot
        i  = l + 1    # A[lt..i-1] == pivot
        gt = r        # A[gt+1..r] > pivot

        while i <= gt:
            if A[i] < pivot:
                A[lt], A[i] = A[i], A[lt]
                lt += 1
                i += 1
            elif A[i] > pivot:
                A[i], A[gt] = A[gt], A[i]
                gt -= 1
            else:
                i += 1

        # Recurse on < pivot and > pivot regions
        _qs(l, lt - 1)
        _qs(gt + 1, r)

    _qs(l, r)
    return A

# Example
arr = [3,1,4,2,5,7,2,3,3,2,2]
print(quicksort_3way(arr))

############################################################
from dataclasses import dataclass
from random import randint, choice, shuffle

@dataclass
class Node:
    val: int | float
    up: "Node | None" = None
    down: "Node | None" = None
    left: "Node | None" = None
    right: "Node | None" = None

    def is_rightmost(self):
        return self.right is None

    def is_bottommost(self):
        return self.down is None

    def __repr__(self):
        return str(self.val)


class SkipList:
    def __init__(self, vals=()):
        self.levels = [self.create_sentinel()]
        self.size = 0
        self.cap = 5
        for v in vals:
            self.insert(v)
        super().__init__()

    def __len__(self):
        return self.size

    def __str__(self):
        ss = []
        for idx, s in enumerate(self.levels):
            l = [f'{idx}:']
            t = s
            while t is not None:
                l.append(str(t))
                t = t.right
            ss.append(' '.join(l))
        return '\n'.join(ss)

    def _will_promote(self):
        return choice((True, False))

    def create_sentinel(self):
        return Node(float('-inf'))

    def find(self, val):
        curr = self.levels[-1]
        self._chain = list()

        for _ in range(len(self.levels)):
            # go right as much as possible at current level
            while not curr.is_rightmost() and val >= curr.right.val:
                curr = curr.right
            self._chain.append(curr)

            # go down next level if possible
            if not curr.is_bottommost():
                curr = curr.down

        self._chain = self._chain[::-1]
        return val == curr.val

    def insert(self, val):

        def insert_and_repoint(node, left, right, down=None):
            node.left = left
            node.right = right
            left.right = node
            if right is not None:
                right.left = node
            if down is not None:
                node.down = down
                down.up = node

        found = self.find(val)
        lvl = 0
        left = self._chain[lvl]
        if not found:
            self.size += 1
            new = Node(val)
            insert_and_repoint(new, left, left.right)

            while self._will_promote():
                lvl += 1
                # if lvl >= self.cap:
                #     break
                if lvl == len(self.levels):
                    sentinel = self.levels[-1]
                    sentinel_up = self.create_sentinel()
                    sentinel.up = sentinel_up
                    sentinel_up.down = sentinel
                    self.levels.append(sentinel_up)

                    new_up = Node(val)
                    insert_and_repoint(
                        new_up, sentinel_up, sentinel_up.right,
                        down=new
                    )

                    new = new_up
                else:
                    left = self._chain[lvl]

                    new_up = Node(val)
                    insert_and_repoint(
                        new_up, left, left.right,
                        down=new
                    )

                    new = new_up

    def delete(self, val):
        found = self.find(val)
        if found:
            self.size -= 1
            node = self._chain[0]
            while node is not None:
                left, right = node.left, node.right
                left.right = right
                if right is not None:
                    right.left = left
                node = node.up
        return found

#####

    def _make_empty_levels(self, h):
        """Return a list of h new sentinel nodes, bottom-first, linked with up/down."""
        levels = [self.create_sentinel() for _ in range(h)]
        # link up/down
        for i in range(len(levels)-1):
            levels[i].up = levels[i+1]
            levels[i+1].down = levels[i]
        return levels

    def _trim_levels(self):
        """Remove top levels that have no real nodes (keep at least one level)."""
        # remove topmost levels while there's more than one level and top sentinel has no right node
        while len(self.levels) > 1 and self.levels[-1].right is None:
            top = self.levels.pop()
            below = self.levels[-1]
            below.up = None
            top.down = None  # help GC (optional)

    def _count_bottom(self):
        """Count nodes on bottom level (not counting sentinel)."""
        cnt = 0
        cur = self.levels[0].right
        while cur is not None:
            cnt += 1
            cur = cur.right
        return cnt

    def split(self, val):
        """
        Split the skiplist into (left, right) where:
          - left contains all elements <= val
          - right contains all elements > val
        This modifies self to be the left list and returns a new SkipList for the right side.
        """
        # ensure chain of predecessors is available for each level
        self.find(val)  # sets self._chain with bottom-first order: _chain[0] = bottom predecessor
        preds = self._chain[:]  # bottom-first list of predecessor nodes, one per level

        h = len(self.levels)
        # create new SkipList for right part but with empty level sentinels
        right = SkipList()
        # create exactly h levels bottom-first
        right.levels = self._make_empty_levels(h)

        # For each level i (bottom=0 .. top=h-1):
        for i in range(h):
            pred = preds[i]
            # the node that will be head.right at this level for the right list
            right_head = pred.right

            # detach right part from pred (left keeps pred.right = None)
            pred.right = None

            # link right sentinel at this level to the old right_head
            right_sentinel = right.levels[i]
            right_sentinel.right = right_head
            if right_head is not None:
                right_head.left = right_sentinel

        # Now link vertical pointers for the new right's sentinels already done in _make_empty_levels

        # Fix any dangling left pointers for the left list top-level sentinels (their right is None already)
        # (No extra action required; we already set pred.right = None.)

        # Fix sizes by counting bottom level for both lists (O(k) in nodes in each half)
        right.size = right._count_bottom()
        self.size = self._count_bottom()

        # Trim empty top levels from both lists (remove levels with no right nodes)
        self._trim_levels()
        right._trim_levels()

        return right



sl = SkipList()
vals = [*range(1, 21)]
shuffle(vals)
for i in vals:
    sl.insert(i)
print(sl)
print('deletes')
for i in vals:
    print(i)
    sl.delete(i)
    print(sl)
    print('---')

############################################################
# Order Statistics
# Given an array a of length n, and k such that 0 ≤ k < n, find the
# element at index k when it is sorted.

from random import randint
from typing import List, Any

def partition(A: List[Any], l: int, r: int) -> int:
    """Lomuto partition: pivot = A[r]; returns pivot final index."""
    pivot = A[r]
    i = l - 1
    for j in range(l, r):
        if A[j] <= pivot:
            i += 1
            A[i], A[j] = A[j], A[i]
    A[i+1], A[r] = A[r], A[i+1]
    return i + 1

def quickselect(A: List[Any], k: int) -> Any:
    """
    Return the element that would be at index k if A were sorted (0-based).
    This modifies A in-place. Expected O(n) time (randomized).
    Raises IndexError if k is out of bounds.
    """
    n = len(A)
    if not (0 <= k < n):
        raise IndexError("k out of bounds")

    def _qs(l: int, r: int) -> Any:
        if l == r:
            return A[l]
        # random pivot to avoid worst-case
        pivot_idx = randint(l, r)
        A[pivot_idx], A[r] = A[r], A[pivot_idx]
        p = partitiono(A, l, r)
        # p is pivot final index
        if k == p:
            return A[p]
        elif k < p:
            return _qs(l, p - 1)
        else:
            return _qs(p + 1, r)

    return _qs(0, n - 1)


# 25 ###########################################################
# five points in line
from random import sample

from dataclasses import dataclass
from fractions import Fraction


@dataclass(frozen=True)
class Point[T: (int, float, Fraction)]:
    # floating-point is evil
    x: T
    y: T
    # z: int

    def __sub__(self, p: "Point") -> "Vec2D":
        return Vec2D(self, p)


class Vec2D:
    def __init__(self, p2: Point, p1: Point = Point(0, 0)):
        self.x = p2.x - p1.x
        self.y = p2.y - p1.y
        super().__init__()

    def __add__(self, v: "Vec2D") -> "Vec2D":
        return Vec2D(
            Point(self.x + v.x, self.y + v.y)
        )

    def __radd__(self, v: "Vec2D") -> "Vec2D":
        return self.__add__(v)

    def __sub__(self, v: "Vec2D") -> "Vec2D":
        return Vec2D(
            Point(self.x - v.x, self.y - v.y)
        )

    def __rmul__(self, s: int) -> "Vec2D":
        return Vec2D(Point(s * self.x, s * self.y))

    def mag2(self) -> int:
        return self.x**2 + self.y**2

    def dot(self, v: "Vec2D") -> int:
        return self.x * v.x + self.y * v.y

    def cross(self, v: "Vec2D") -> int:
        return self.x * v.y - self.y * v.x


points_with_answer = [
    (4, 4), (-1, -18), (8, -14), (-3, 20), (7, 5),
    (16, -3), (-9, -13), (-14, -19), (-2, -17), (6, 8),
    (-11, -3), (-9, 6), (-3, 2), (-15, -4), (0, -17),
    (11, 13), (8, -13), (10, 7), (3, -7), (18, -6),
    (19, -3), (0, -13), (4, -5),
    (4, 7), (6, 7)
]
points_with_no_answer = [
    (4, 4), (-1, -18), (8, -14), (-3, 20), (7, 5),
    (16, -3), (-9, -13), (-14, -19), (-2, -17), (6, 8),
    (-11, -3), (-9, 6), (-3, 2), (-15, -4), (0, -17),
    (11, 13), (8, -13), (10, 7), (3, -7), (18, -6),
    (19, -3), (0, -13), (4, -500), # (4, -5),
    (4, 7), (6, 7)
]

def find_line_brute(points):
    pts = [Point(*p) for p in points]
    n = len(pts)
    for i in range(n):
        for j in range(i + 1, n):
            p_i = pts[i]
            p_j = pts[j]
            count = 0
            for k in range(n):
                p_k = pts[k]
                v1 = p_j - p_i
                v2 = p_k - p_i
                # collinear check
                if v1.cross(v2) == 0:
                    count += 1
            if count * 5 >= n:
                return (p_i, p_j)
    return None


def find_line_lasvegas(points):
    pts = [Point(*p) for p in points]
    attempts = 0
    while True:
        attempts += 1
        p1, p2 = sample(pts, 2)
        count = 0
        for p3 in pts:
            v1 = p3 - p1
            v2 = p3 - p2
            if v1.cross(v2) == 0:
                count += 1
        if count >= len(pts) / 5:
            return attempts, (p1, p2)


def find_line_mc(points):
    pts = [Point(*p) for p in points]
    attempts = 0
    K = 2000
    for _ in range(K):
        attempts += 1
        p1, p2 = sample(pts, 2)
        count = 0
        for p3 in pts:
            v1 = p3 - p1
            v2 = p3 - p2
            if v1.cross(v2) == 0:
                count += 1
        if count >= len(pts) / 5:
            return attempts, (p1, p2)
    return attempts, None


num_attempts, ans = find_line_lasvegas(points_with_answer)
print(num_attempts, ans)
num_attempts, ans = find_line_mc(points_with_answer)
print(num_attempts, ans)
num_attempts, ans = find_line_mc(points_with_no_answer)
print(num_attempts, ans)

# 26 ###########################################################
# Hashing
class HashMapChaining:
    """
    A simple Hash Map implementation using Separate Chaining.
    """
    def __init__(self, capacity=10):
        # c is the capacity (number of buckets)
        self.capacity = capacity 
        # .a: array of lists (buckets), initialized to 'capacity' empty lists
        self.buckets = [[] for _ in range(self.capacity)]

    def _hash(self, key):
        """
        The hash function h(k). 
        Uses Python's built-in hash() and the modulo operator to get an index 
        within the array bounds [0, capacity - 1].
        """
        # Ensure the hash result is non-negative and within capacity
        return hash(key) % self.capacity

    def set(self, key, value):
        """
        Inserts or updates the value associated with the key.
        Corresponds to the .set(k, v) method.
        """
        index = self._hash(key)
        bucket = self.buckets[index]

        # 1. Search for an existing key and update if found
        for i, (k_prime, v_prime) in enumerate(bucket):
            if k_prime == key:
                # Replace old entry: .a[h(k)][i] ≔ (k, v)
                bucket[i] = (key, value)
                return

        # 2. If key is new, append the new entry
        # .a[h(k)].append((k, v))
        bucket.append((key, value))

    def get(self, key):
        """
        Retrieves the value associated with the key.
        Corresponds to the .get(k) method.
        """
        index = self._hash(key)
        bucket = self.buckets[index]

        # 1. Iterate the chain and return value if key is found
        for k_prime, v_prime in bucket:
            if k_prime == key:
                return v_prime
        
        # 2. Key not found: key error
        raise KeyError(f"Key '{key}' not found in the map")

# --- Example Usage ---
my_map = HashMapChaining(capacity=5)

# Insert new entries
my_map.set("apple", 100)
my_map.set("banana", 200)
my_map.set("cherry", 300)

# Retrieve a value
print(f"Value for 'banana': {my_map.get('banana')}")

# Update an entry
my_map.set("apple", 150)
print(f"New value for 'apple': {my_map.get('apple')}")

# Show the underlying structure (demonstrates chaining/hashing)
print("\nUnderlying Buckets:")
for i, chain in enumerate(my_map.buckets):
    print(f"Bucket {i}: {chain}")

# Example of a key error
try:
    my_map.get("grape")
except KeyError as e:
    print(f"\nCaught Error: {e}")

############################################################

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

// Define the capacity of our hash table (the number of "buckets")
#define CAPACITY 10

// --- Data Structures ---

// 1. Node Structure (for the Linked List/Chain)
// Each node holds a key-value pair and points to the next entry in the chain.
typedef struct Node {
    char* key;           // The string key
    int value;           // The integer value
    struct Node* next;   // Pointer to the next node in the chain
} Node;

// 2. Hash Map Structure
typedef struct {
    Node* buckets[CAPACITY]; // Array of pointers to the head of each linked list (chain)
} HashMap;


// --- Core Functions ---

// 1. Hash Function (h(k))
// A simple, effective string hashing function (djb2 algorithm) followed by modulo.
unsigned int hash_function(const char* key) {
    unsigned long hash = 5381; // Initial seed value
    int c;

    // Iterate through the string, updating the hash
    while ((c = *key++)) {
        // hash * 33 + c
        hash = ((hash << 5) + hash) + c; 
    }

    // Apply modulo to ensure the index is within the array bounds [0, CAPACITY - 1]
    return hash % CAPACITY;
}

// 2. Initialization Function
HashMap* create_map() {
    HashMap* map = (HashMap*)malloc(sizeof(HashMap));
    if (map == NULL) {
        perror("Failed to allocate memory for HashMap");
        exit(EXIT_FAILURE);
    }
    // Initialize all bucket pointers to NULL (empty chains)
    for (int i = 0; i < CAPACITY; i++) {
        map->buckets[i] = NULL;
    }
    return map;
}

// 3. Set Function (Insert/Update)
void set(HashMap* map, const char* key, int value) {
    // 1. Find the bucket index using the hash function
    unsigned int index = hash_function(key);
    
    // Start iterating the chain at the calculated bucket index
    Node* current = map->buckets[index];

    // Search for an existing key (Update if found)
    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            // Key found: Replace old entry with the new value
            current->value = value;
            return;
        }
        current = current->next;
    }

    // If we reach here, the key is new. Create a new entry.

    // Allocate memory for the new node
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        perror("Failed to allocate memory for Node");
        return;
    }

    // Allocate and copy the key string
    newNode->key = strdup(key);
    if (newNode->key == NULL) {
        free(newNode);
        perror("Failed to allocate memory for key");
        return;
    }
    
    // Set value
    newNode->value = value;
    
    // Insert the new node at the beginning of the chain (Add new entry)
    newNode->next = map->buckets[index];
    map->buckets[index] = newNode;
}

// 4. Get Function (Lookup)
// Returns the value if key is found, otherwise -1 (or a custom error indicator).
int get(HashMap* map, const char* key) {
    // 1. Find the bucket index
    unsigned int index = hash_function(key);
    
    // Start iterating the chain
    Node* current = map->buckets[index];
    
    // Search for the key
    while (current != NULL) {
        if (strcmp(current->key, key) == 0) {
            // Key found: return the value
            return current->value;
        }
        current = current->next;
    }

    // Key not found: simulate "key error" by returning a special value
    return -1; 
}

// 5. Cleanup Function
void destroy_map(HashMap* map) {
    for (int i = 0; i < CAPACITY; i++) {
        Node* current = map->buckets[i];
        while (current != NULL) {
            Node* temp = current;
            current = current->next;
            free(temp->key); // Free the dynamically allocated key string
            free(temp);      // Free the node itself
        }
    }
    free(map); // Free the HashMap structure
}


// --- Main Demonstration ---

int main() {
    printf("--- Hash Map Implementation (Separate Chaining) ---\n");
    
    // Create the map
    HashMap* my_map = create_map();

    // The key-to-index mapping:
    // "apple" -> hash_function("apple") % 10 = 1
    // "banana" -> hash_function("banana") % 10 = 6
    // "pear" -> hash_function("pear") % 10 = 1 (Collision with "apple"!)

    // 1. Insertion (Set)
    set(my_map, "apple", 100);
    set(my_map, "banana", 200);
    set(my_map, "cherry", 300);
    set(my_map, "pear", 400); // Collision with "apple" at index 1

    printf("\n--- Insertions Complete ---\n");
    
    // 2. Retrieval (Get)
    printf("Value of 'apple': %d\n", get(my_map, "apple")); // Found
    printf("Value of 'pear': %d\n", get(my_map, "pear"));   // Found (despite collision)
    printf("Value of 'banana': %d\n", get(my_map, "banana")); // Found
    printf("Value of 'grape': %d (Expected -1 for not found)\n", get(my_map, "grape")); // Not Found

    // 3. Update (Set existing key)
    set(my_map, "apple", 150);
    printf("\n--- Update 'apple' to 150 ---\n");
    printf("New value of 'apple': %d\n", get(my_map, "apple")); // Should be 150

    // 4. Inspecting the Buckets (Manual check of chaining)
    printf("\n--- Internal Bucket Check (Capacity: %d) ---\n", CAPACITY);
    for (int i = 0; i < CAPACITY; i++) {
        Node* current = my_map->buckets[i];
        if (current) {
            printf("Bucket %d:", i);
            while (current) {
                printf(" -> ('%s': %d)", current->key, current->value);
                current = current->next;
            }
            printf("\n");
        }
    }
    
    // 5. Cleanup
    destroy_map(my_map);
    printf("\nMemory cleaned up.\n");

    return 0;
}

############################################################

class Point:
    def __init__(self, x, y):
        # We make the attributes private and treat them as immutable for hashing
        self._x = x
        self._y = y

    # The custom hash function
    def __hash__(self):
        # We hash the Point object by combining the hashes of its components (x and y).
        # We use a tuple (self._x, self._y) because tuples are reliably hashable.
        return hash((self._x, self._y))

    # To ensure it works as a key, you must also define __eq__
    def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return self._x == other._x and self._y == other._y

p1 = Point(5, 10)
p2 = Point(5, 10) # A different object instance, but equal state
p3 = Point(1, 1)

print(f"\nHash of p1: {hash(p1)}")
print(f"Hash of p2: {hash(p2)}") # Should be the same as p1
print(f"Hash of p3: {hash(p3)}")

# p1 can now be used as a key in a dictionary
my_dict = {p1: "Start Point"}
print(my_dict[p2]) # Output: Start Point (p2 successfully finds p1's value because they have the same hash and are equal)
############################################################
