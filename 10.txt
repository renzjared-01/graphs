from collections import defaultdict
from typing import Iterable, Dict, List, Optional, Tuple, Any

def make_adjacency_list(G) -> Dict[Any, List[Any]]:
    """
    Accepts either:
      - a dict mapping node -> iterable of neighbors (used as-is), or
      - an iterable of edges (u, v). Edges are treated as undirected.
    Returns a dict mapping node -> list of neighbors.
    """
    if isinstance(G, dict):
        return {k: list(v) for k, v in G.items()}
    adj = defaultdict(list)
    for edge in G:
        if len(edge) < 2:
            continue
        u, v = edge[0], edge[1]
        adj[u].append(v)
        adj[v].append(u)  # treat as undirected; remove this line for directed graphs
    return dict(adj)

def construct_path(parent: Dict[Any, Any], start: Any, end: Any) -> List[Any]:
    """Reconstruct path from start to end using parent map. Returns list of nodes from start..end."""
    path = []
    cur = end
    while True:
        path.append(cur)
        if cur == start:
            break
        cur = parent.get(cur)
        if cur is None:
            # parent chain broken -> no path
            return []
    path.reverse()
    return path

def find_path(G, x, y) -> Optional[List[Any]]:
    """
    Find a path from node x to node y in graph G using DFS (stack).
    Returns a list of nodes representing the path x -> ... -> y, or None if no path exists.
    G may be either an adjacency dict or an iterable of (u, v) edges.
    """
    adj = make_adjacency_list(G)

    # quick check: if start or end not in graph, no path
    if x not in adj or y not in adj:
        return None

    visited = set()
    parent: Dict[Any, Any] = {}
    to_visit = []  # use list as stack

    visited.add(x)
    to_visit.append(x)

    while to_visit:
        u = to_visit.pop()
        for v in adj.get(u, []):
            if v not in visited:
                visited.add(v)
                parent[v] = u
                to_visit.append(v)
        if y in visited:
            return construct_path(parent, x, y)

    # finished search and y wasn't reached
    return None

# Example usage:
if __name__ == "__main__":
    # adjacency dict example
    G_dict = {
        0: [1, 2],
        1: [0, 3],
        2: [0],
        3: [1]
    }
    print(find_path(G_dict, 0, 3))  # -> [0, 1, 3]

    # edge list example (undirected)
    edges = [(0, 1), (0, 2), (1, 3)]
    print(find_path(edges, 2, 3))  # -> [2, 0, 1, 3]


############################
DAG Shortest Path
def dag_shortest_path(n, edges, s, t):
    assert 0 <= s < n
    assert 0 <= t < n

    adj = [[] for _ in range(n)]
    for i, j, w in edges:
        adj[i].append((j, w))

    done = [False]*n
    memo = [None]*n

    def d(x):
        if not done[x]:
            if x == t:
                ans = 0
            else:
                ans = float('inf')
                for y, w in adj[x]:
                    ans = min(ans, w + d(y))

            done[x] = True
            memo[x] = ans

        return memo[x]

    return d(s)


if __name__ == '__main__':
    n = 7
    edges = [
        (1, 0, 1),
        (1, 4, 1),
        (2, 0, 1),
        (3, 0, 1),
        (3, 2, 1),
        (6, 2, 1),
        (6, 5, 1),
        (5, 2, 1),
        (5, 1, 1),
        (6, 3, 1),
    ]
    s, t = 6, 0
    print(dag_shortest_path(n, edges, s, t))

-----------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

typedef long long ll;
const ll INF = (1LL<<60);

/* adjacency using edge arrays (safe and efficient) */
int *head, *to, *nxt, *wt;
int edge_cnt = 0;

void init_graph(int n, int m) {
    head = (int*)malloc((n+1)*sizeof(int));
    for (int i = 0; i <= n; ++i) head[i] = -1;
    to  = (int*)malloc(m * sizeof(int));
    nxt = (int*)malloc(m * sizeof(int));
    wt  = (int*)malloc(m * sizeof(int));
    edge_cnt = 0;
}

void add_edge(int u, int v, int w) {
    to[edge_cnt] = v;
    wt[edge_cnt] = w;
    nxt[edge_cnt] = head[u];
    head[u] = edge_cnt++;
}

/* DFS topo */
void dfs_topo(int u, int *vis, int *stack, int *stack_sz) {
    vis[u] = 1;
    for (int e = head[u]; e != -1; e = nxt[e]) {
        int v = to[e];
        if (!vis[v]) dfs_topo(v, vis, stack, stack_sz);
    }
    /* push u onto stack (post-order) */
    stack[(*stack_sz)++] = u;
}

/* shortest paths in DAG from source 'src' */
void shortest_path_dag(int n, int src, ll *dist, int *stack, int stack_sz) {
    for (int i = 0; i < n; ++i) dist[i] = INF;
    dist[src] = 0;

    /* nodes in topo order: stack currently is reverse topo (postorder),
       so iterate from stack_sz-1 down to 0, or reverse the stack. */
    for (int i = stack_sz - 1; i >= 0; --i) {
        int u = stack[i];
        if (dist[u] == INF) continue; /* unreachable, skip relax */
        for (int e = head[u]; e != -1; e = nxt[e]) {
            int v = to[e];
            ll w = wt[e];
            if (dist[u] + w < dist[v]) dist[v] = dist[u] + w;
        }
    }
}

int main(void) {
    /* Example usage:
       n = number of vertices (0..n-1)
       m = number of edges
       edges: (u -> v, weight)
    */
    int n = 7;
    int m = 11; /* allocate at least number of edges you'll add */

    init_graph(n, m);

    /* sample edges (same as you used earlier, add weights) */
    add_edge(1, 0, 2);
    add_edge(1, 4, 3);
    add_edge(2, 0, 1);
    add_edge(3, 0, 4);
    add_edge(3, 2, -2);  /* negative weight allowed on DAG */
    add_edge(6, 2, 2);
    add_edge(6, 5, 1);
    add_edge(5, 2, 2);
    add_edge(5, 1, 1);
    add_edge(6, 3, 1);
    add_edge(0, 4, 5);

    /* topological sort via DFS */
    int *vis = (int*)calloc(n, sizeof(int));
    int *stack = (int*)malloc(n * sizeof(int));
    int stack_sz = 0;
    for (int i = 0; i < n; ++i) {
        if (!vis[i]) dfs_topo(i, vis, stack, &stack_sz);
    }

    /* optional: verify stack_sz == n for a DAG with all nodes visited
       (if there are cycles, this DFS-based approach will still return
       an ordering but it won't be a valid topo order â€” usually we detect
       cycles with a 3-color DFS if needed). For most DAG usage this is fine. */

    /* compute shortest paths from source (choose source node) */
    int src = 6;
    ll *dist = (ll*)malloc(n * sizeof(ll));
    shortest_path_dag(n, src, dist, stack, stack_sz);

    /* print distances */
    printf("Shortest distances from %d:\n", src);
    for (int i = 0; i < n; ++i) {
        if (dist[i] == INF) printf("node %d: INF\n", i);
        else printf("node %d: %lld\n", i, dist[i]);
    }

    /* cleanup */
    free(head); free(to); free(nxt); free(wt);
    free(vis); free(stack); free(dist);
    return 0;
}



#############################
Kahn Toposort
def toposort(n, edges):
    indeg = [0]*n
    adj = [[] for _ in range(n)]
    for i, j in edges:
        indeg[j] += 1
        adj[i].append(j)

    sources = [i for i in range(n) if indeg[i] == 0]

    res = []
    while sources:
        i = sources.pop()
        res.append(i)
        for j in adj[i]:
            indeg[j] -= 1
            if indeg[j] == 0:
                sources.append(j)

    return res if len(res) == n else None


if __name__ == '__main__':
    n = 7
    edges = [
        (1, 0),
        (1, 4),
        (2, 0),
        (3, 0),
        (3, 2),
        (6, 2),
        (6, 5),
        (5, 2),
        (5, 1),
        (6, 3),
        # (0, 6),
        # (0, 5),
    ]
    print(toposort(n, edges))
--------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

#define MAXN 1000  // max number of nodes

int adj[MAXN][MAXN]; // adjacency matrix (for simplicity)
int n;               // number of nodes
int indeg[MAXN];     // optional for Kahn
int visited[MAXN];
int topo[MAXN];      // stores topological order
int topo_idx;        // current index for topo array
int adj_size[MAXN];  // number of neighbors for each node

void dfs(int u) {
    visited[u] = 1;
    for (int i = 0; i < adj_size[u]; i++) {
        int v = adj[u][i];
        if (!visited[v]) dfs(v);
    }
    topo[topo_idx++] = u; // append after visiting neighbors (postorder)
}

int main() {
    n = 6; // example nodes 0..5

    // Example graph edges (directed)
    // 5 -> 2, 5 -> 0, 4 -> 0, 4 -> 1, 2 -> 3, 3 -> 1
    adj_size[5] = 2; adj[5][0] = 2; adj[5][1] = 0;
    adj_size[4] = 2; adj[4][0] = 0; adj[4][1] = 1;
    adj_size[2] = 1; adj[2][0] = 3;
    adj_size[3] = 1; adj[3][0] = 1;

    // Initialize visited array
    for (int i = 0; i < n; i++) visited[i] = 0;

    topo_idx = 0;
    for (int i = 0; i < n; i++) {
        if (!visited[i]) dfs(i);
    }

    // topo[] is in reverse postorder, reverse it
    printf("Topological order:\n");
    for (int i = topo_idx-1; i >= 0; i--) {
        printf("%d ", topo[i]);
    }
    printf("\n");

    return 0;
}


#########################################
TREES
def adj_from_edgelist(n, edges):
    adj = {u: [] for u in range(n)}
    for (u, v) in edges:
        adj[u].append(v)
        adj[v].append(u)
    return adj


def rooted_tree_from_edgelist(n, edges, root):
    assert len(edges) == n - 1

    adj = adj_from_edgelist(n, edges)
    vis = set([root])
    stak = [root]

    children = [[] for _ in range(n)]

    while stak:
        u = stak.pop()
        for v in adj[u]:
            if v not in vis:
                children[u].append(v)
                vis.add(v)
                stak.append(v)

    # connected check
    assert len(vis) == n

    return children


def get_diameter(n, edges):
    root = 1
    tree = rooted_tree_from_edgelist(n, edges, root)

    farthest_desc = [-1 for _ in range(n)]

    def _f(i):
        farthest_desc[i] = 1 + max((_f(j) for j in tree[i]), default=-1)
        return farthest_desc[i]

    _f(root)


    diameter = 0
    for i in range(n):
        if not tree[i]:
            diameter = max(diameter, 0)
        elif len(tree[i]) == 1:
            diameter = max(diameter, 1 + farthest_desc[tree[i][0]])
        else:
            top_two = []
            for j in tree[i]:
                if len(top_two) < 2:
                    top_two.append(farthest_desc[j])
                    top_two.sort(reverse=True)  # this is constant time for <= 2 elements
                elif farthest_desc[j] > top_two[0]:
                    top_two[0], top_two[1] = farthest_desc[j], top_two[0]
                elif top_two[0] >= farthest_desc[j] > top_two[1]:
                    top_two[1] = farthest_desc[j]
            diameter = max(diameter, 2 + sum(top_two))

    return diameter


def diameter2(n, edges):

    def farthest(adj, u):
        stak, vis = [u], set([u])
        dists = [0] * n
        while stak:
            u = stak.pop()
            for v in adj[u]:
                if v not in vis:
                    vis.add(v)
                    stak.append(v)
                    dists[v] = dists[u] + 1
        assert len(vis) == n
        far = max(dists)
        return (next((v for v in range(n) if dists[v] == far)), far)

    assert len(edges) == n - 1
    adj = adj_from_edgelist(n, edges)
    start_node = 0
    next_node, _ = farthest(adj, start_node)
    nexter_node, dist = farthest(adj, next_node)
    return dist


edgelist = [
    (0, 1),
    (0, 8),
    (1, 2),
    (1, 3),
    (1, 6),
    (1, 7),
    (3, 4),
    (3, 5),
    (8, 9)
]
n = 10
root = 1

t = rooted_tree_from_edgelist(n, edgelist, root)
for i in range(len(t)):
    print(f'{i}: {t[i]}')
print(get_diameter(n, edgelist))

#################################
lexicographically minimal toposort

import heapq

def lexicographically_minimal_toposort(n, edges):
    indeg = [0]*n
    adj = [[] for _ in range(n)]
    for u, v in edges:
        indeg[v] += 1
        adj[u].append(v)

    heap = [i for i in range(n) if indeg[i] == 0]
    heapq.heapify(heap)

    res = []
    while heap:
        u = heapq.heappop(heap)   # pick smallest available source
        res.append(u)
        for v in adj[u]:
            indeg[v] -= 1
            if indeg[v] == 0:
                heapq.heappush(heap, v)

    return res if len(res) == n else None  # None => cycle

######################################
class UnionFind:
    def __init__(self, n):
        self.parent = [*range(n)]
        self.size = [1]*n
        super().__init__()

    def is_root(self, i):
        return i == self.parent[i]

    def find(self, i):
        self.parent[i] = i if self.is_root(i) else self.find(self.parent[i])
        return self.parent[i]

    def union(self, i, j):
        i = self.find(i)
        j = self.find(j)
        if i == j:
            return False

        assert i != j

        if self.size[j] < self.size[i]:
            i, j = j, i

        assert self.size[j] >= self.size[i]

        self.parent[i] = j
        self.size[j] += self.size[i]

        return True


def weight(edge):
    u, v, w = edge
    return w


def cost(edges):
    return sum(w for u, v, w in edges)


def mst(n, edges):
    comps = DisjointSets(n)
    tree = []
    for u, v, w in sorted(edges, key=weight):
        if comps.find(u) != comps.find(v):
            comps.union(u, v)
            tree.append((u, v, w))
    return cost(tree)


if __name__ == '__main__':
    print(mst(10, [
        (0, 1, 2),
        (1, 2, 10),
        (2, 3, 15),
        (3, 4, 8),
        (2, 4, 16),
        (4, 6, 25),
        (4, 5, 10),
        (5, 6, 10),
        (6, 7, 1),
        (7, 9, 2),
        (7, 8, 3),
        (8, 9, 2),
    ]))
