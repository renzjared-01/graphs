from collections import defaultdict
from typing import Iterable, Dict, List, Optional, Tuple, Any

def make_adjacency_list(G) -> Dict[Any, List[Any]]:
    """
    Accepts either:
      - a dict mapping node -> iterable of neighbors (used as-is), or
      - an iterable of edges (u, v). Edges are treated as undirected.
    Returns a dict mapping node -> list of neighbors.
    """
    if isinstance(G, dict):
        return {k: list(v) for k, v in G.items()}
    adj = defaultdict(list)
    for edge in G:
        if len(edge) < 2:
            continue
        u, v = edge[0], edge[1]
        adj[u].append(v)
        adj[v].append(u)  # treat as undirected; remove this line for directed graphs
    return dict(adj)

def construct_path(parent: Dict[Any, Any], start: Any, end: Any) -> List[Any]:
    """Reconstruct path from start to end using parent map. Returns list of nodes from start..end."""
    path = []
    cur = end
    while True:
        path.append(cur)
        if cur == start:
            break
        cur = parent.get(cur)
        if cur is None:
            # parent chain broken -> no path
            return []
    path.reverse()
    return path

def find_path(G, x, y) -> Optional[List[Any]]:
    """
    Find a path from node x to node y in graph G using DFS (stack).
    Returns a list of nodes representing the path x -> ... -> y, or None if no path exists.
    G may be either an adjacency dict or an iterable of (u, v) edges.
    """
    adj = make_adjacency_list(G)

    # quick check: if start or end not in graph, no path
    if x not in adj or y not in adj:
        return None

    visited = set()
    parent: Dict[Any, Any] = {}
    to_visit = []  # use list as stack

    visited.add(x)
    to_visit.append(x)

    while to_visit:
        u = to_visit.pop()
        for v in adj.get(u, []):
            if v not in visited:
                visited.add(v)
                parent[v] = u
                to_visit.append(v)
        if y in visited:
            return construct_path(parent, x, y)

    # finished search and y wasn't reached
    return None

# Example usage:
if __name__ == "__main__":
    # adjacency dict example
    G_dict = {
        0: [1, 2],
        1: [0, 3],
        2: [0],
        3: [1]
    }
    print(find_path(G_dict, 0, 3))  # -> [0, 1, 3]

    # edge list example (undirected)
    edges = [(0, 1), (0, 2), (1, 3)]
    print(find_path(edges, 2, 3))  # -> [2, 0, 1, 3]


############################
DAG Shortest Path
def dag_shortest_path(n, edges, s, t):
    assert 0 <= s < n
    assert 0 <= t < n

    adj = [[] for _ in range(n)]
    for i, j, w in edges:
        adj[i].append((j, w))

    done = [False]*n
    memo = [None]*n

    def d(x):
        if not done[x]:
            if x == t:
                ans = 0
            else:
                ans = float('inf')
                for y, w in adj[x]:
                    ans = min(ans, w + d(y))

            done[x] = True
            memo[x] = ans

        return memo[x]

    return d(s)


if __name__ == '__main__':
    n = 7
    edges = [
        (1, 0, 1),
        (1, 4, 1),
        (2, 0, 1),
        (3, 0, 1),
        (3, 2, 1),
        (6, 2, 1),
        (6, 5, 1),
        (5, 2, 1),
        (5, 1, 1),
        (6, 3, 1),
    ]
    s, t = 6, 0
    print(dag_shortest_path(n, edges, s, t))



#############################
Kahn Toposort
def toposort(n, edges):
    indeg = [0]*n
    adj = [[] for _ in range(n)]
    for i, j in edges:
        indeg[j] += 1
        adj[i].append(j)

    sources = [i for i in range(n) if indeg[i] == 0]

    res = []
    while sources:
        i = sources.pop()
        res.append(i)
        for j in adj[i]:
            indeg[j] -= 1
            if indeg[j] == 0:
                sources.append(j)

    return res if len(res) == n else None


if __name__ == '__main__':
    n = 7
    edges = [
        (1, 0),
        (1, 4),
        (2, 0),
        (3, 0),
        (3, 2),
        (6, 2),
        (6, 5),
        (5, 2),
        (5, 1),
        (6, 3),
        # (0, 6),
        # (0, 5),
    ]
    print(toposort(n, edges))


#########################################
TREES
def adj_from_edgelist(n, edges):
    adj = {u: [] for u in range(n)}
    for (u, v) in edges:
        adj[u].append(v)
        adj[v].append(u)
    return adj


def rooted_tree_from_edgelist(n, edges, root):
    assert len(edges) == n - 1

    adj = adj_from_edgelist(n, edges)
    vis = set([root])
    stak = [root]

    children = [[] for _ in range(n)]

    while stak:
        u = stak.pop()
        for v in adj[u]:
            if v not in vis:
                children[u].append(v)
                vis.add(v)
                stak.append(v)

    # connected check
    assert len(vis) == n

    return children


def get_diameter(n, edges):
    root = 1
    tree = rooted_tree_from_edgelist(n, edges, root)

    farthest_desc = [-1 for _ in range(n)]

    def _f(i):
        farthest_desc[i] = 1 + max((_f(j) for j in tree[i]), default=-1)
        return farthest_desc[i]

    _f(root)


    diameter = 0
    for i in range(n):
        if not tree[i]:
            diameter = max(diameter, 0)
        elif len(tree[i]) == 1:
            diameter = max(diameter, 1 + farthest_desc[tree[i][0]])
        else:
            top_two = []
            for j in tree[i]:
                if len(top_two) < 2:
                    top_two.append(farthest_desc[j])
                    top_two.sort(reverse=True)  # this is constant time for <= 2 elements
                elif farthest_desc[j] > top_two[0]:
                    top_two[0], top_two[1] = farthest_desc[j], top_two[0]
                elif top_two[0] >= farthest_desc[j] > top_two[1]:
                    top_two[1] = farthest_desc[j]
            diameter = max(diameter, 2 + sum(top_two))

    return diameter


def diameter2(n, edges):

    def farthest(adj, u):
        stak, vis = [u], set([u])
        dists = [0] * n
        while stak:
            u = stak.pop()
            for v in adj[u]:
                if v not in vis:
                    vis.add(v)
                    stak.append(v)
                    dists[v] = dists[u] + 1
        assert len(vis) == n
        far = max(dists)
        return (next((v for v in range(n) if dists[v] == far)), far)

    assert len(edges) == n - 1
    adj = adj_from_edgelist(n, edges)
    start_node = 0
    next_node, _ = farthest(adj, start_node)
    nexter_node, dist = farthest(adj, next_node)
    return dist


edgelist = [
    (0, 1),
    (0, 8),
    (1, 2),
    (1, 3),
    (1, 6),
    (1, 7),
    (3, 4),
    (3, 5),
    (8, 9)
]
n = 10
root = 1

t = rooted_tree_from_edgelist(n, edgelist, root)
for i in range(len(t)):
    print(f'{i}: {t[i]}')
print(get_diameter(n, edgelist))
    
