from collections import defaultdict
from typing import Iterable, Dict, List, Optional, Tuple, Any

def make_adjacency_list(G) -> Dict[Any, List[Any]]:
    """
    Accepts either:
      - a dict mapping node -> iterable of neighbors (used as-is), or
      - an iterable of edges (u, v). Edges are treated as undirected.
    Returns a dict mapping node -> list of neighbors.
    """
    if isinstance(G, dict):
        return {k: list(v) for k, v in G.items()}
    adj = defaultdict(list)
    for edge in G:
        if len(edge) < 2:
            continue
        u, v = edge[0], edge[1]
        adj[u].append(v)
        adj[v].append(u)  # treat as undirected; remove this line for directed graphs
    return dict(adj)

def construct_path(parent: Dict[Any, Any], start: Any, end: Any) -> List[Any]:
    """Reconstruct path from start to end using parent map. Returns list of nodes from start..end."""
    path = []
    cur = end
    while True:
        path.append(cur)
        if cur == start:
            break
        cur = parent.get(cur)
        if cur is None:
            # parent chain broken -> no path
            return []
    path.reverse()
    return path

def find_path(G, x, y) -> Optional[List[Any]]:
    """
    Find a path from node x to node y in graph G using DFS (stack).
    Returns a list of nodes representing the path x -> ... -> y, or None if no path exists.
    G may be either an adjacency dict or an iterable of (u, v) edges.
    """
    adj = make_adjacency_list(G)

    # quick check: if start or end not in graph, no path
    if x not in adj or y not in adj:
        return None

    visited = set()
    parent: Dict[Any, Any] = {}
    to_visit = []  # use list as stack

    visited.add(x)
    to_visit.append(x)

    while to_visit:
        u = to_visit.pop()
        for v in adj.get(u, []):
            if v not in visited:
                visited.add(v)
                parent[v] = u
                to_visit.append(v)
        if y in visited:
            return construct_path(parent, x, y)

    # finished search and y wasn't reached
    return None

# Example usage:
if __name__ == "__main__":
    # adjacency dict example
    G_dict = {
        0: [1, 2],
        1: [0, 3],
        2: [0],
        3: [1]
    }
    print(find_path(G_dict, 0, 3))  # -> [0, 1, 3]

    # edge list example (undirected)
    edges = [(0, 1), (0, 2), (1, 3)]
    print(find_path(edges, 2, 3))  # -> [2, 0, 1, 3]


############################
DAG Shortest Path
def dag_shortest_path(n, edges, s, t):
    assert 0 <= s < n
    assert 0 <= t < n

    adj = [[] for _ in range(n)]
    for i, j, w in edges:
        adj[i].append((j, w))

    done = [False]*n
    memo = [None]*n

    def d(x):
        if not done[x]:
            if x == t:
                ans = 0
            else:
                ans = float('inf')
                for y, w in adj[x]:
                    ans = min(ans, w + d(y))

            done[x] = True
            memo[x] = ans

        return memo[x]

    return d(s)


if __name__ == '__main__':
    n = 7
    edges = [
        (1, 0, 1),
        (1, 4, 1),
        (2, 0, 1),
        (3, 0, 1),
        (3, 2, 1),
        (6, 2, 1),
        (6, 5, 1),
        (5, 2, 1),
        (5, 1, 1),
        (6, 3, 1),
    ]
    s, t = 6, 0
    print(dag_shortest_path(n, edges, s, t))



#############################
Kahn Toposort
def toposort(n, edges):
    indeg = [0]*n
    adj = [[] for _ in range(n)]
    for i, j in edges:
        indeg[j] += 1
        adj[i].append(j)

    sources = [i for i in range(n) if indeg[i] == 0]

    res = []
    while sources:
        i = sources.pop()
        res.append(i)
        for j in adj[i]:
            indeg[j] -= 1
            if indeg[j] == 0:
                sources.append(j)

    return res if len(res) == n else None


if __name__ == '__main__':
    n = 7
    edges = [
        (1, 0),
        (1, 4),
        (2, 0),
        (3, 0),
        (3, 2),
        (6, 2),
        (6, 5),
        (5, 2),
        (5, 1),
        (6, 3),
        # (0, 6),
        # (0, 5),
    ]
    print(toposort(n, edges))


#########################################
