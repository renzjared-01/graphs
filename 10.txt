from collections import defaultdict
from typing import Iterable, Dict, List, Optional, Tuple, Any

def make_adjacency_list(G) -> Dict[Any, List[Any]]:
    """
    Accepts either:
      - a dict mapping node -> iterable of neighbors (used as-is), or
      - an iterable of edges (u, v). Edges are treated as undirected.
    Returns a dict mapping node -> list of neighbors.
    """
    if isinstance(G, dict):
        return {k: list(v) for k, v in G.items()}
    adj = defaultdict(list)
    for edge in G:
        if len(edge) < 2:
            continue
        u, v = edge[0], edge[1]
        adj[u].append(v)
        adj[v].append(u)  # treat as undirected; remove this line for directed graphs
    return dict(adj)

def construct_path(parent: Dict[Any, Any], start: Any, end: Any) -> List[Any]:
    """Reconstruct path from start to end using parent map. Returns list of nodes from start..end."""
    path = []
    cur = end
    while True:
        path.append(cur)
        if cur == start:
            break
        cur = parent.get(cur)
        if cur is None:
            # parent chain broken -> no path
            return []
    path.reverse()
    return path

def find_path(G, x, y) -> Optional[List[Any]]:
    """
    Find a path from node x to node y in graph G using DFS (stack).
    Returns a list of nodes representing the path x -> ... -> y, or None if no path exists.
    G may be either an adjacency dict or an iterable of (u, v) edges.
    """
    adj = make_adjacency_list(G)

    # quick check: if start or end not in graph, no path
    if x not in adj or y not in adj:
        return None

    visited = set()
    parent: Dict[Any, Any] = {}
    to_visit = []  # use list as stack

    visited.add(x)
    to_visit.append(x)

    while to_visit:
        u = to_visit.pop()
        for v in adj.get(u, []):
            if v not in visited:
                visited.add(v)
                parent[v] = u
                to_visit.append(v)
        if y in visited:
            return construct_path(parent, x, y)

    # finished search and y wasn't reached
    return None

# Example usage:
if __name__ == "__main__":
    # adjacency dict example
    G_dict = {
        0: [1, 2],
        1: [0, 3],
        2: [0],
        3: [1]
    }
    print(find_path(G_dict, 0, 3))  # -> [0, 1, 3]

    # edge list example (undirected)
    edges = [(0, 1), (0, 2), (1, 3)]
    print(find_path(edges, 2, 3))  # -> [2, 0, 1, 3]






#############################


