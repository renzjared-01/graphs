# MST
## Prim's
from heapq import heappush, heappop

def make_adj(n, edges):
    adj = [[] for _ in range(n)]
    for edge in edges:
        i, j, c = edge
        adj[i].append((j, c, edge))
        adj[j].append((i, c, edge))
    return adj

def mst(n, edges):
    adj = make_adj(n, edges)

    vis = [False]*n
    start = 0
    pq = [(0, start, None)]
    tree = []
    while pq:
        d, i, edge = heappop(pq)
        if vis[i]:
            continue
        if edge is not None:
            tree.append(edge)
        vis[i] = True
        for j, c, edge in adj[i]:
            heappush(pq, (c, j, edge))
    return tree

def mst_cost(n, edges):
    return sum(c for i, j, c in mst(n, edges))

def main():
    print(mst(5, [
        (0, 1, 2),
        (0, 4, 6),
        (1, 4, 4),
        (2, 4, 1),
        (2, 1, 7),
        (2, 3, 8),
        (4, 3, 5),
    ]))

if __name__ == '__main__':
    main()

## Kruskal's
from random import getrandbits

class UnionFind:
    def __init__(self, n):
        self.p = [-1]*n
        super().__init__()

    def __getitem__(self, i):
        if self.p[i] < 0:
            return i
        else:
            self.p[i] = self[self.p[i]]
            return self.p[i]

    def union(self, i, j):
        if (i := self[i]) == (j := self[j]):
            return False

        if getrandbits(1) == 0:  # union by random
            i, j = j, i
        self.p[i] = j
        return True


def mst(n, edges):
    comps = UnionFind(n)
    def key(edge):
        i, j, c = edge
        return c

    tree = []
    for i, j, c in sorted(edges, key=key):
        if comps[i] != comps[j]:
            tree.append((i, j, c))
            comps.union(i, j)

    return tree


def mst_cost(n, edges):
    return sum(c for i, j, c in mst(n, edges))


def main():
    print(mst(5, [
        (0, 1, 2),
        (0, 4, 6),
        (1, 4, 4),
        (2, 4, 1),
        (2, 1, 7),
        (2, 3, 8),
        (4, 3, 5),
    ]))


if __name__ == '__main__':
    main()

## PRoblem 1
import sys
input = sys.stdin.readline

n = int(input())

x = [0] * n
y = [0] * n
c = [0] * n
k = [0] * n

for i in range(n):
    x[i], y[i] = map(int, input().split())

c = list(map(int, input().split()))
k = list(map(int, input().split()))

INF = 10**18

# dist[i] = minimum cost to connect city i to electricity
dist = c[:]                  # initially: build power station
parent = [-1] * n             # -1 means connected to power source
used = [False] * n

total_cost = 0
power_stations = []
connections = []

for _ in range(n):
    # pick unused city with smallest dist
    u = -1
    best = INF
    for i in range(n):
        if not used[i] and dist[i] < best:
            best = dist[i]
            u = i

    used[u] = True
    total_cost += dist[u]

    if parent[u] == -1:
        power_stations.append(u + 1)
    else:
        connections.append((parent[u] + 1, u + 1))

    # relax edges
    for v in range(n):
        if not used[v]:
            cost = (k[u] + k[v]) * (abs(x[u] - x[v]) + abs(y[u] - y[v]))
            if cost < dist[v]:
                dist[v] = cost
                parent[v] = u

# Output
print(total_cost)
print(len(power_stations))
print(*power_stations)
print(len(connections))
for u, v in connections:
    print(u, v)

# x[i], y[i] = distance of city i from shrine
# c[i] cost to build power station in city i
# k[i] base cost connecting city i using wire


# Shortest Path
def edgelist_to_adj(n: int, edgelist: list[WeightedEdge], directed=False) -> dict[int, list[tuple[int, int]]]:
    adj = {i: [] for i in range(n)}
    for w, i, j in edgelist:
        adj[i].append((w, j))
        if not directed:
            adj[j].append((w, i))
    return adj

## Bellman-Ford
### Shortest dists from a source node, works with negative weights, detects negative cycles

INF = 10**18

def bellman_ford(n, edges, source):
    """
    n: number of vertices (0 to n-1)
    edges: list of (u, v, w) edges
    source: source vertex
    Returns:
        dist[]: shortest distances
        has_negative_cycle: True/False
    """
    dist = [INF] * n
    dist[source] = 0

    # Relax all edges n-1 times
    for _ in range(n - 1):
        updated = False
        for u, v, w in edges:
            if dist[u] != INF and dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                updated = True
        if not updated:
            break

    # Check for negative cycle
    has_negative_cycle = False
    for u, v, w in edges:
        if dist[u] != INF and dist[v] > dist[u] + w:
            has_negative_cycle = True
            break

    return dist, has_negative_cycle


## Floyd's
### All pairs sp, handles negative weights, detects neg cycles
INF = 10**18

def floyd_warshall(n, edges):
    """
    n: number of vertices (0 to n-1)
    edges: list of (u, v, w) edges (directed or undirected)
    Returns:
        dist: n x n distance matrix
        has_negative_cycle: True/False
    """
    # Initialize distance matrix
    dist = [[INF] * n for _ in range(n)]
    for i in range(n):
        dist[i][i] = 0

    for u, v, w in edges:
        dist[u][v] = min(dist[u][v], w)

    # Main DP
    for k in range(n):
        for i in range(n):
            for j in range(n):
                if dist[i][k] + dist[k][j] < dist[i][j]:
                    dist[i][j] = dist[i][k] + dist[k][j]

    # Detect negative cycles
    has_negative_cycle = False
    for i in range(n):
        if dist[i][i] < 0:
            has_negative_cycle = True
            break

    return dist, has_negative_cycle


##
